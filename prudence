#! /usr/bin/python

# Copyright 2020 by Vincent Fourmond
# This program is free software. It is distributed under the terms of the
# GNU General Public License version 3.0 or later, found at
# https://www.gnu.org/copyleft/gpl.html
#
# There is NO WARRANTY.

# Prudence is an attempt to organize my backups that are delocalized
# across many places.

import argparse
import os
import os.path
import socket
import subprocess

class prudence(object):
    """The main class"""

    instance = None
    
    def __init__(self):
        self.conffile = os.environ['HOME'] + "/.prudence"
        self.sources = []
        self.stores = []
        self.dry_run = False
        if prudence.instance is None:
            prudence.instance = self


    def parse_config(self):
        code = open(self.conffile).read()
        context = dict()
        context["p"] = self
        exec code in context

    def run_backup(self):
        """Runs the actual backup job"""
        for s in self.sources:
            for st in self.stores:
                # Only save to local stores ?
                if st.is_local():
                    s.sync_to(st)

    def dump_config(self):
        """Dumps the configuration to standard output"""
        print "Sources:"
        for s in self.sources:
            print " * %s" % s.dump()
        print "\nStorage places:"
        for st in self.stores:
            print " * %s" % st.dump()


    def run(self):
        parser = argparse.ArgumentParser()
        parser.add_argument("-D", "--dump-config",action="store_true",
                            help="dumps the configuration")
        parser.add_argument("-N", "--dry-run",action="store_true",
                            help="only shows the command-lines instead of running them")
        parser.add_argument("-c", "--conffile", type=str,
                            help="alternate location of the configuration file")
        args = parser.parse_args()
        if args.conffile:
            self.conffile = args.conffile
        cmd = self.run_backup
        if args.dump_config:
            cmd = self.dump_config
        if args.dry_run:
            self.dry_run = True

        self.parse_config()
        cmd()


    def launch(self, command):
        if self.dry_run:
            print command
        else:
            subprocess.call(command)
        

    @staticmethod
    def system(command):
        prudence.instance.launch(command)
        

    def store(self, hst, dirname, git_sub = "git", rsync_sub = "rsync"):
        """Used from the config file to add one store"""
        self.stores.append(store(hst, dirname, git_sub, rsync_sub))

    def git(self, host, path):
        """Used in the config file to add a git source"""
        self.sources.append(git_source(host, path))

class host(object):
    """This class represents a host"""
    def __init__(self, name):
        self.name = name

    @staticmethod
    def host_name():
        """Returns the host name part of the current host"""
        return socket.gethostname().split(".")[0]

    def is_local(self):
        """Returns true if the host is the computer prudence is running from"""
        return host.host_name() == self.name
        

    def __str__(self):
        return self.name

class store(object):
    """A place that can receive data"""

    def __init__(self, hst, dirname, git_sub = "git", rsync_sub = "rsync"):
        """Designates a storage place at the given host and directory"""
        self.host = host(hst)
        self.dirname = dirname
        self.git = git_sub
        self.rsync = rsync_sub

    def only_remote(self):
        """Returns true if the store is only remote, that is no instance of prudence will ever run on that host to keep it up-to-date"""

    def available_space(self):
        """Returns the available space in the given storage"""

    def git_dir(self):
        """Returns the directory where one can store git repositories"""
        return "%s/%s" % (self.dirname, self.git)
        
    def rsync_dir(self):
        """Returns the directory where one can store rsync backups"""

    def dump(self):
        local = "local" if self.is_local() else "remote"
        if self.is_local():
            stat = os.statvfs(self.dirname)
            sz = (stat.f_frsize * stat.f_bavail)/(1024*1024)
            local = "%s -- %d MB available" % (local, sz)
        return "%s:%s (%s)" % (self.host, self.dirname, local)

    def is_local(self):
        return self.host.is_local()

class source(object):
    """This is the base class for all kinds of sources of data"""

    def __init__(self, hst, name):
        self.host = host(hst)
        self.name = name

    def can_sync_to(self, store):
        """Returns true if the source can be sync'ed (saved) to the target store"""
        return True             # for now

    def sync_to(self, store):
        """Does the actual synchronization"""

    def status_in(self, store):
        """Gives the status of this data source in the given store"""

    def approximative_size(self):
        """Returns the size in KiB. Should be cached"""

    def size_in(self, store):
        """Returns the storage size in the given store"""

    def dump(self):
        """Returns a string describing the source"""

class git_source(source):
    def __init__(self, host, path):
        super(git_source, self).__init__(host, os.path.basename(path))
        self.path = path
        self.final_name = self.name
        if not self.final_name.endswith(".git"):
            self.final_name += ".git"


    def loc(self):
        return "%s:%s" % (self.host, self.path)

    def sync_to(self, store):
        """Does the actual synchronization"""
        target = "%s/%s" % (store.git_dir(), self.final_name)
        if not os.path.exists(target):
            os.makedirs(target)

        owd = os.getcwd()
        os.chdir(store.git_dir())
        # check if the objects directory is present or not ?
        if not os.path.exists(self.final_name + "/objects"):
            # Cloning
            cmd = ('git',
                   'clone',
                   '-c', 'pack.threads=1',
                   '-c', 'pack.packSizeLimit=2G',
                   '-c', 'core.bigfilethreshold=50m',
                   '--bare', self.loc(), self.final_name)
            prudence.system(cmd)
        else:
            os.chdir(self.final_name)
            cmd = ('git', 'fetch',
                   '--verbose',
                   'origin',
                   '+refs/heads/*:refs/heads/*')
            prudence.system(cmd)
        os.chdir(owd)

    def dump(self):
        local = "local" if self.host.is_local() else "remote"
        return "git: %s (%s)" % (self.loc(), local)


p = prudence()

p.run()
